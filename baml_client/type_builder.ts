/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ npm install @boundaryml/baml
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code

import { FieldType } from '@boundaryml/baml/native'
import { TypeBuilder as _TypeBuilder, EnumBuilder, EnumViewer, ClassBuilder, ClassViewer } from '@boundaryml/baml/type_builder'
import { DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME } from "./globals"

export { FieldType, EnumBuilder, ClassBuilder }

export default class TypeBuilder {
    private tb: _TypeBuilder;
    
    Act: ClassViewer<'Act', "setup" | "incitingIncident" | "plotPoint1" | "confrontation" | "midpoint" | "plotPoint2" | "climax" | "fallingAction" | "resolution" | "duration">;
    
    ActStructure: ClassViewer<'ActStructure', "act1" | "act2" | "act3">;
    
    AdaptiveAct: ClassViewer<'AdaptiveAct', "actNumber" | "name" | "description" | "duration" | "keyEvents" | "purpose">;
    
    Character: ClassViewer<'Character', "name" | "role" | "archetype" | "characterDevelopment" | "characterArc" | "physicalDescription" | "dialogueVoice" | "relationships" | "generationMetadata">;
    
    CharacterArc: ClassViewer<'CharacterArc', "startState" | "transformation" | "endState">;
    
    CharacterDevelopmentDetails: ClassViewer<'CharacterDevelopmentDetails', "biography" | "personality" | "motivations" | "backstory" | "psychology">;
    
    CharacterDevelopmentResponse: ClassViewer<'CharacterDevelopmentResponse', "characters" | "qualityMetrics" | "generationNotes">;
    
    CharacterGenerationMetadata: ClassViewer<'CharacterGenerationMetadata', "generatedAt" | "generationMethod" | "qualityScore" | "completeness">;
    
    CharacterPsychology: ClassViewer<'CharacterPsychology', "motivation" | "fears" | "desires" | "flaws">;
    
    CharacterQualityMetrics: ClassViewer<'CharacterQualityMetrics', "overallQuality" | "characterDepth" | "arcConsistency" | "relationshipClarity" | "dialogueDistinction" | "psychologicalRealism">;
    
    CharacterRelationship: ClassViewer<'CharacterRelationship', "character" | "relationship" | "dynamic">;
    
    DialogueVoice: ClassViewer<'DialogueVoice', "voiceDescription" | "style" | "patterns" | "vocabulary">;
    
    InitialStoryResponse: ClassViewer<'InitialStoryResponse', "storyContent" | "qualityMetrics" | "generationNotes">;
    
    NarrativeStructure: ClassViewer<'NarrativeStructure', "structureType" | "adaptiveActs" | "sequences" | "saveTheCatBeats">;
    
    PhysicalDescription: ClassViewer<'PhysicalDescription', "description" | "age" | "height" | "eyeColor" | "hairColor" | "clothing">;
    
    ProjectFieldsResponse: ClassViewer<'ProjectFieldsResponse', "projectTitle" | "shortDescription" | "longDescription">;
    
    QualityAssessment: ClassViewer<'QualityAssessment', "overallScore" | "breakdown">;
    
    QualityBreakdown: ClassViewer<'QualityBreakdown', "clearThreeActProgression" | "strongCharacterArcs" | "compellingStoryBeats" | "effectiveSubplotIntegration" | "cinematicPotential">;
    
    QualityMetric: ClassViewer<'QualityMetric', "score" | "justification">;
    
    QualityMetrics: ClassViewer<'QualityMetrics', "overallQuality" | "structureScore" | "characterDepth" | "coherenceScore" | "conflictTension" | "dialogueQuality" | "genreAlignment" | "audienceEngagement" | "visualStorytelling" | "productionReadiness">;
    
    SaveTheCatBeat: ClassViewer<'SaveTheCatBeat', "beatNumber" | "name" | "description" | "pageNumber" | "timing" | "purpose">;
    
    SequenceStructure: ClassViewer<'SequenceStructure', "sequenceNumber" | "name" | "description" | "duration" | "miniMovieArc" | "keyBeats">;
    
    StoryBeat: ClassViewer<'StoryBeat', "beatId" | "beat" | "timestamp" | "timing" | "description" | "charactersPresent" | "characters" | "emotionalTone">;
    
    StoryStructureResponse: ClassViewer<'StoryStructureResponse', "narrativeStructure" | "storyBeats" | "characterArcs" | "subplots" | "qualityScore" | "qualityAssessment" | "generationNotes">;
    
    StructureValidationResponse: ClassViewer<'StructureValidationResponse', "isReady" | "overallScore" | "strengths" | "weaknesses" | "recommendations" | "criticalIssues">;
    
    Subplot: ClassViewer<'Subplot', "subplotName" | "name" | "description" | "resolution" | "charactersInvolved" | "involvedCharacters">;
    
    

    constructor() {
        this.tb = new _TypeBuilder({
          classes: new Set([
            "Act","ActStructure","AdaptiveAct","Character","CharacterArc","CharacterDevelopmentDetails","CharacterDevelopmentResponse","CharacterGenerationMetadata","CharacterPsychology","CharacterQualityMetrics","CharacterRelationship","DialogueVoice","InitialStoryResponse","NarrativeStructure","PhysicalDescription","ProjectFieldsResponse","QualityAssessment","QualityBreakdown","QualityMetric","QualityMetrics","SaveTheCatBeat","SequenceStructure","StoryBeat","StoryStructureResponse","StructureValidationResponse","Subplot",
          ]),
          enums: new Set([
            
          ]),
          runtime: DO_NOT_USE_DIRECTLY_UNLESS_YOU_KNOW_WHAT_YOURE_DOING_RUNTIME
        });
        
        this.Act = this.tb.classViewer("Act", [
          "setup","incitingIncident","plotPoint1","confrontation","midpoint","plotPoint2","climax","fallingAction","resolution","duration",
        ]);
        
        this.ActStructure = this.tb.classViewer("ActStructure", [
          "act1","act2","act3",
        ]);
        
        this.AdaptiveAct = this.tb.classViewer("AdaptiveAct", [
          "actNumber","name","description","duration","keyEvents","purpose",
        ]);
        
        this.Character = this.tb.classViewer("Character", [
          "name","role","archetype","characterDevelopment","characterArc","physicalDescription","dialogueVoice","relationships","generationMetadata",
        ]);
        
        this.CharacterArc = this.tb.classViewer("CharacterArc", [
          "startState","transformation","endState",
        ]);
        
        this.CharacterDevelopmentDetails = this.tb.classViewer("CharacterDevelopmentDetails", [
          "biography","personality","motivations","backstory","psychology",
        ]);
        
        this.CharacterDevelopmentResponse = this.tb.classViewer("CharacterDevelopmentResponse", [
          "characters","qualityMetrics","generationNotes",
        ]);
        
        this.CharacterGenerationMetadata = this.tb.classViewer("CharacterGenerationMetadata", [
          "generatedAt","generationMethod","qualityScore","completeness",
        ]);
        
        this.CharacterPsychology = this.tb.classViewer("CharacterPsychology", [
          "motivation","fears","desires","flaws",
        ]);
        
        this.CharacterQualityMetrics = this.tb.classViewer("CharacterQualityMetrics", [
          "overallQuality","characterDepth","arcConsistency","relationshipClarity","dialogueDistinction","psychologicalRealism",
        ]);
        
        this.CharacterRelationship = this.tb.classViewer("CharacterRelationship", [
          "character","relationship","dynamic",
        ]);
        
        this.DialogueVoice = this.tb.classViewer("DialogueVoice", [
          "voiceDescription","style","patterns","vocabulary",
        ]);
        
        this.InitialStoryResponse = this.tb.classViewer("InitialStoryResponse", [
          "storyContent","qualityMetrics","generationNotes",
        ]);
        
        this.NarrativeStructure = this.tb.classViewer("NarrativeStructure", [
          "structureType","adaptiveActs","sequences","saveTheCatBeats",
        ]);
        
        this.PhysicalDescription = this.tb.classViewer("PhysicalDescription", [
          "description","age","height","eyeColor","hairColor","clothing",
        ]);
        
        this.ProjectFieldsResponse = this.tb.classViewer("ProjectFieldsResponse", [
          "projectTitle","shortDescription","longDescription",
        ]);
        
        this.QualityAssessment = this.tb.classViewer("QualityAssessment", [
          "overallScore","breakdown",
        ]);
        
        this.QualityBreakdown = this.tb.classViewer("QualityBreakdown", [
          "clearThreeActProgression","strongCharacterArcs","compellingStoryBeats","effectiveSubplotIntegration","cinematicPotential",
        ]);
        
        this.QualityMetric = this.tb.classViewer("QualityMetric", [
          "score","justification",
        ]);
        
        this.QualityMetrics = this.tb.classViewer("QualityMetrics", [
          "overallQuality","structureScore","characterDepth","coherenceScore","conflictTension","dialogueQuality","genreAlignment","audienceEngagement","visualStorytelling","productionReadiness",
        ]);
        
        this.SaveTheCatBeat = this.tb.classViewer("SaveTheCatBeat", [
          "beatNumber","name","description","pageNumber","timing","purpose",
        ]);
        
        this.SequenceStructure = this.tb.classViewer("SequenceStructure", [
          "sequenceNumber","name","description","duration","miniMovieArc","keyBeats",
        ]);
        
        this.StoryBeat = this.tb.classViewer("StoryBeat", [
          "beatId","beat","timestamp","timing","description","charactersPresent","characters","emotionalTone",
        ]);
        
        this.StoryStructureResponse = this.tb.classViewer("StoryStructureResponse", [
          "narrativeStructure","storyBeats","characterArcs","subplots","qualityScore","qualityAssessment","generationNotes",
        ]);
        
        this.StructureValidationResponse = this.tb.classViewer("StructureValidationResponse", [
          "isReady","overallScore","strengths","weaknesses","recommendations","criticalIssues",
        ]);
        
        this.Subplot = this.tb.classViewer("Subplot", [
          "subplotName","name","description","resolution","charactersInvolved","involvedCharacters",
        ]);
        
        
    }

    reset(): void {
        this.tb.reset();
        // TODO: This should happen in Rust. Problem is, when we construct the
        // typebuilder we instantiate class builders once and it seems to make
        // a JS copy, bypassing the Rust side? In Python however, every time we
        // access a class builder with @property, we get a new instance that
        // wraps over the Rust type builder, so we only need to call tb.reset().
        // In JS it's not possible unless we refactor the way class builders are
        // accessed.
        
    }

    __tb() {
      return this.tb._tb();
    }

    string(): FieldType {
        return this.tb.string()
    }

    literalString(value: string): FieldType {
        return this.tb.literalString(value)
    }

    literalInt(value: number): FieldType {
        return this.tb.literalInt(value)
    }

    literalBool(value: boolean): FieldType {
        return this.tb.literalBool(value)
    }

    int(): FieldType {
        return this.tb.int()
    }

    float(): FieldType {
        return this.tb.float()
    }

    bool(): FieldType {
        return this.tb.bool()
    }

    list(type: FieldType): FieldType {
        return this.tb.list(type)
    }

    null(): FieldType {
        return this.tb.null()
    }

    map(key: FieldType, value: FieldType): FieldType {
        return this.tb.map(key, value)
    }

    union(types: FieldType[]): FieldType {
        return this.tb.union(types)
    }

    addClass<Name extends string>(name: Name): ClassBuilder<Name> {
        return this.tb.addClass(name);
    }

    addEnum<Name extends string>(name: Name): EnumBuilder<Name> {
        return this.tb.addEnum(name);
    }

    addBaml(baml: string): void {
        this.tb.addBaml(baml);
    }
}