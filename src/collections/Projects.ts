import type { CollectionConfig } from 'payload'

export const Projects: CollectionConfig = {
  slug: 'projects',
  admin: {
    useAsTitle: 'name',
    defaultColumns: ['name', 'projectTitle', 'movieFormat', 'status', 'updatedAt'],
    group: 'Content',
  },
  access: {
    read: () => true,
    create: ({ req: { user } }) => {
      // All authenticated users can create projects
      return !!user
    },
    update: ({ req: { user } }) => {
      return !!user
    },
    delete: ({ req: { user } }) => {
      return !!user
    },
  },
  fields: [
    {
      name: 'slug',
      type: 'text',
      maxLength: 6,
      unique: true,
      hooks: {
        beforeValidate: [
          async ({ value, data, req, operation }) => {
            // Generate if slug is not provided or is empty
            if (!value && data?.name) {
              const generateSlug = (name: string): string => {
                // Remove special characters and convert to lowercase
                const cleaned = name
                  .toLowerCase()
                  .replace(/[^a-z0-9]/g, '')
                  .substring(0, 6)

                // Pad with random lowercase letters if less than 6 characters
                if (cleaned.length < 6) {
                  const chars = 'abcdefghijklmnopqrstuvwxyz'
                  let result = cleaned
                  while (result.length < 6) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length))
                  }
                  return result
                }

                return cleaned
              }

              const checkUniqueness = async (slug: string): Promise<string> => {
                // Build where clause - exclude current document if updating
                const whereClause: any = { slug: { equals: slug } }
                if (operation === 'update' && data.id) {
                  whereClause.id = { not_equals: data.id }
                }

                const existing = await req.payload.find({
                  collection: 'projects',
                  where: whereClause,
                  limit: 1,
                })

                if (existing.totalDocs === 0) {
                  return slug
                }

                // If not unique, generate variations by replacing last character(s)
                const chars = 'abcdefghijklmnopqrstuvwxyz'
                for (let i = 0; i < 26; i++) {
                  const newSlug = slug.substring(0, 5) + chars[i]
                  const checkWhere: any = { slug: { equals: newSlug } }
                  if (operation === 'update' && data.id) {
                    checkWhere.id = { not_equals: data.id }
                  }

                  const check = await req.payload.find({
                    collection: 'projects',
                    where: checkWhere,
                    limit: 1,
                  })

                  if (check.totalDocs === 0) {
                    return newSlug
                  }
                }

                // If still not unique, try replacing last 2 characters
                for (let i = 0; i < 26; i++) {
                  for (let j = 0; j < 26; j++) {
                    const newSlug = slug.substring(0, 4) + chars[i] + chars[j]
                    const checkWhere: any = { slug: { equals: newSlug } }
                    if (operation === 'update' && data.id) {
                      checkWhere.id = { not_equals: data.id }
                    }

                    const check = await req.payload.find({
                      collection: 'projects',
                      where: checkWhere,
                      limit: 1,
                    })

                    if (check.totalDocs === 0) {
                      return newSlug
                    }
                  }
                }

                // Fallback: generate completely random 6-character slug
                let randomSlug = ''
                for (let i = 0; i < 6; i++) {
                  randomSlug += chars.charAt(Math.floor(Math.random() * chars.length))
                }
                return randomSlug
              }

              const baseSlug = generateSlug(data.name)
              return await checkUniqueness(baseSlug)
            }

            return value
          },
        ],
      },
    },
    {
      name: 'name',
      type: 'text',
      required: true,
      admin: {
        description:
          'Project identifier/name provided by user (e.g., "Adventure Story 1", "Mystery Episode 3")',
      },
    },
    {
      name: 'projectTitle',
      type: 'text',
      admin: {
        description:
          'The actual title of the movie/episode (user-provided or auto-generated by frontend)',
      },
    },
    {
      name: 'shortDescription',
      type: 'textarea',
      admin: {
        description: 'Brief summary of the project (user-provided or auto-generated by frontend)',
      },
    },
    {
      name: 'longDescription',
      type: 'textarea',
      admin: {
        description:
          'Detailed description or synopsis of the project (user-provided or auto-generated by frontend)',
      },
    },
    {
      name: 'movieFormat',
      type: 'relationship',
      relationTo: 'movie-formats',
      required: true,
      admin: {
        description: 'The format type for this project (Short Film, Feature Film, Series, etc.)',
      },
    },
    {
      name: 'series',
      type: 'relationship',
      relationTo: 'series',
      admin: {
        description: 'Associated series (only required/visible when movieFormat is "Series")',
        condition: (data, siblingData) => {
          // Show this field only when movie format is series
          if (siblingData?.movieFormat && typeof siblingData.movieFormat === 'object') {
            return siblingData.movieFormat.slug === 'series'
          }
          return false
        },
      },
    },
    {
      name: 'movieStyle',
      type: 'relationship',
      relationTo: 'movie-styles',
      required: true,
      admin: {
        description: 'Visual/artistic style for AI generation',
      },
    },
    {
      name: 'status',
      type: 'select',
      required: true,
      defaultValue: 'draft',
      options: [
        {
          label: 'Draft',
          value: 'draft',
        },
        {
          label: 'In Progress',
          value: 'in-progress',
        },
        {
          label: 'Completed',
          value: 'completed',
        },
        {
          label: 'Archived',
          value: 'archived',
        },
      ],
      admin: {
        description: 'Current status of the project',
      },
    },
    {
      name: 'durationUnit',
      type: 'number',
      required: true,
      admin: {
        description: 'Unit of measurement for the suggested duration in minutes',
      },
    },
    {
      name: 'generatedContent',
      type: 'group',
      admin: {
        description: 'Container for AI-generated content and assets',
      },
      fields: [
        {
          name: 'script',
          type: 'richText',
          admin: {
            description: 'Generated screenplay/script content',
          },
        },
        {
          name: 'scenes',
          type: 'array',
          admin: {
            description: 'Generated scenes with text and media references',
          },
          fields: [
            {
              name: 'sceneNumber',
              type: 'number',
              required: true,
              admin: {
                description: 'Sequential scene number',
              },
            },
            {
              name: 'description',
              type: 'textarea',
              admin: {
                description: 'Scene description or script content',
              },
            },
            {
              name: 'media',
              type: 'relationship',
              relationTo: 'media',
              hasMany: true,
              admin: {
                description: 'Media assets associated with this scene',
              },
            },
          ],
        },
        {
          name: 'finalVideo',
          type: 'relationship',
          relationTo: 'media',
          admin: {
            description: 'Final assembled video file',
          },
        },
        {
          name: 'assets',
          type: 'relationship',
          relationTo: 'media',
          hasMany: true,
          admin: {
            description: 'All generated assets for this project',
          },
        },
      ],
    },
    // Workflow Relationships
    {
      name: 'initialConcept',
      type: 'relationship',
      relationTo: 'initial-concepts',
      admin: {
        description: 'Associated initial concept for this project',
        readOnly: true,
      },
      hooks: {
        beforeValidate: [
          async ({ data, req }) => {
            // Auto-populate the reverse relationship
            if (data && req) {
              const existingConcept = await req.payload.find({
                collection: 'initial-concepts',
                where: {
                  project: { equals: data.id },
                },
                limit: 1,
              })

              if (existingConcept.totalDocs > 0) {
                return existingConcept.docs[0].id
              }
            }
            return data?.initialConcept
          },
        ],
      },
    },
    {
      name: 'workflowStatus',
      type: 'group',
      admin: {
        description: 'Workflow progress tracking',
      },
      fields: [
        {
          name: 'currentStep',
          type: 'select',
          defaultValue: 'project-setup',
          options: [
            { label: 'Project Setup', value: 'project-setup' },
            { label: 'Initial Concept', value: 'initial-concept' },
            { label: 'Story Generation', value: 'story-generation' },
            { label: 'Character Development', value: 'character-development' },
            { label: 'Scene Planning', value: 'scene-planning' },
            { label: 'Media Generation', value: 'media-generation' },
            { label: 'Post Production', value: 'post-production' },
            { label: 'Final Review', value: 'final-review' },
            { label: 'Completed', value: 'completed' },
          ],
          admin: {
            description: 'Current workflow step',
          },
        },
        {
          name: 'completedSteps',
          type: 'array',
          fields: [
            {
              name: 'step',
              type: 'text',
              required: true,
            },
            {
              name: 'completedAt',
              type: 'date',
              required: true,
            },
          ],
          admin: {
            description: 'List of completed workflow steps with timestamps',
          },
        },
        {
          name: 'lastActivity',
          type: 'date',
          admin: {
            description: 'Last time this project was worked on',
            readOnly: true,
          },
          hooks: {
            beforeValidate: [
              () => {
                return new Date()
              },
            ],
          },
        },
      ],
    },
  ],
  hooks: {
    afterChange: [
      async ({ doc, operation }) => {
        // Update workflow status when project changes
        if (operation === 'update') {
          console.log(
            `Project ${doc.id} updated - Current step: ${doc.workflowStatus?.currentStep}`,
          )
        }
      },
    ],
  },
}
