'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { Sparkles, Trash2 } from 'lucide-react'
import {
  MovieFormat,
  MovieStyle,
  Series,
  Genre,
  AudienceDemographic,
  ToneOption,
} from '@/payload-types'
import FormField from '@/components/forms/FormField'
import Input from '@/components/forms/Input'
import Textarea from '@/components/forms/Textarea'
import Select from '@/components/forms/Select'
import MultiSelect from '@/components/forms/MultiSelect'
import SelectWithCreate from '@/components/ui/SelectWithCreate'
import Button from '@/components/ui/Button'
import LoadingSpinner from '@/components/ui/LoadingSpinner'
import ToastContainer, { useToast } from '@/components/ui/ToastContainer'
import CreateSeriesModal from '@/components/modals/CreateSeriesModal'
import DashboardLayout from '@/components/layout/DashboardLayout'

interface FormData {
  name: string
  projectTitle: string
  shortDescription: string
  longDescription: string
  movieFormat: string
  series: string
  movieStyle: string
  durationUnit: string
  // Core Required Fields for Story Generation
  primaryGenres: string[]
  corePremise: string
  targetAudience: string[]
  tone: string[]
}

interface FormErrors {
  [key: string]: string
}

interface AIGeneratedFields {
  projectTitle?: boolean
  shortDescription?: boolean
  longDescription?: boolean
}

export default function CreateProjectPage() {
  const router = useRouter()
  const { toasts, removeToast, success, error } = useToast()
  const [formData, setFormData] = useState<FormData>({
    name: '',
    projectTitle: '',
    shortDescription: '',
    longDescription: '',
    movieFormat: '',
    series: '',
    movieStyle: '',
    durationUnit: '',
    // Core Required Fields for Story Generation
    primaryGenres: [],
    corePremise: '',
    targetAudience: [],
    tone: [],
  })

  // Track which fields were generated by AI
  const [aiGeneratedFields, setAiGeneratedFields] = useState<AIGeneratedFields>({})
  const [aiLoading, setAiLoading] = useState(false)
  const [coreElementsAiLoading, setCoreElementsAiLoading] = useState(false)
  const [errors, setErrors] = useState<FormErrors>({})
  const [loading, setLoading] = useState(false)
  const [initialLoading, setInitialLoading] = useState(true)
  const [movieFormats, setMovieFormats] = useState<MovieFormat[]>([])
  const [movieStyles, setMovieStyles] = useState<MovieStyle[]>([])
  const [seriesList, setSeriesList] = useState<Series[]>([])
  const [showSeriesField, setShowSeriesField] = useState(false)
  const [showCreateSeriesModal, setShowCreateSeriesModal] = useState(false)
  // New relationship data for core required fields
  const [genres, setGenres] = useState<Genre[]>([])
  const [audienceDemographics, setAudienceDemographics] = useState<AudienceDemographic[]>([])
  const [toneOptions, setToneOptions] = useState<ToneOption[]>([])

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [formatsRes, stylesRes, seriesRes, genresRes, audienceRes, toneRes] =
          await Promise.all([
            fetch('/v1/movie-formats'),
            fetch('/v1/movie-styles'),
            fetch('/v1/series'),
            fetch('/v1/config/genres'),
            fetch('/v1/config/audience-demographics'),
            fetch('/v1/config/tone-options'),
          ])

        const [formatsData, stylesData, seriesData, genresData, audienceData, toneData] =
          await Promise.all([
            formatsRes.json(),
            stylesRes.json(),
            seriesRes.json(),
            genresRes.json(),
            audienceRes.json(),
            toneRes.json(),
          ])

        if (formatsData.success) setMovieFormats(formatsData.data.docs)
        if (stylesData.success) setMovieStyles(stylesData.data.docs)
        if (seriesData.success) setSeriesList(seriesData.data.docs)
        if (genresData.success) setGenres(genresData.data)
        if (audienceData.success) setAudienceDemographics(audienceData.data)
        if (toneData.success) setToneOptions(toneData.data)
      } catch (error) {
        console.error('Error fetching form data:', error)
      } finally {
        setInitialLoading(false)
      }
    }

    fetchData()
  }, [])

  useEffect(() => {
    // Check if selected movie format is "series"
    const selectedFormat = movieFormats.find((format) => format.id === formData.movieFormat)
    setShowSeriesField(selectedFormat?.slug === 'series')

    // Clear series selection if not needed
    if (selectedFormat?.slug !== 'series') {
      setFormData((prev) => ({ ...prev, series: '' }))
    }
  }, [formData.movieFormat, movieFormats])

  const handleInputChange = (field: keyof FormData, value: string | string[]) => {
    setFormData((prev) => ({ ...prev, [field]: value }))
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors((prev) => ({ ...prev, [field]: '' }))
    }
  }

  const handleSeriesCreated = (newSeries: { id: string; name: string }) => {
    // Add the new series to the list
    setSeriesList((prev) => [...prev, { id: newSeries.id, name: newSeries.name } as Series])
    // Select the newly created series
    setFormData((prev) => ({ ...prev, series: newSeries.id }))
    // Close the modal
    setShowCreateSeriesModal(false)
    // Show success message
    success(
      'Series created successfully!',
      `"${newSeries.name}" has been added to your series list.`,
    )
  }

  // Check if all required fields are filled
  const areRequiredFieldsFilled = () => {
    const requiredFields = ['name', 'movieFormat', 'movieStyle', 'durationUnit']
    const allBasicFieldsFilled = requiredFields.every((field) =>
      formData[field as keyof FormData]?.trim(),
    )

    // If series field is shown, it must also be filled
    if (showSeriesField) {
      return allBasicFieldsFilled && formData.series?.trim()
    }

    return allBasicFieldsFilled
  }

  // Handle AI auto-fill
  const handleAIAutoFill = async () => {
    if (!areRequiredFieldsFilled()) {
      error('AI Auto-fill Error', 'Please fill in all required fields first.')
      return
    }

    setAiLoading(true)

    try {
      const requestData = {
        name: formData.name,
        movieFormat: formData.movieFormat,
        movieStyle: formData.movieStyle,
        durationUnit: formData.durationUnit,
        ...(showSeriesField && { series: formData.series }),
        // Include existing optional fields as context
        projectTitle: formData.projectTitle || undefined,
        shortDescription: formData.shortDescription || undefined,
        longDescription: formData.longDescription || undefined,
        // Include existing core required fields as context
        primaryGenres: formData.primaryGenres.length > 0 ? formData.primaryGenres : undefined,
        corePremise: formData.corePremise || undefined,
        targetAudience: formData.targetAudience.length > 0 ? formData.targetAudience : undefined,
        tone: formData.tone.length > 0 ? formData.tone : undefined,
      }

      const response = await fetch('/v1/projects/ai-autofill', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
      })

      const result = await response.json()

      if (result.success && result.data?.generatedFields) {
        const { generatedFields } = result.data
        const newAiGeneratedFields: AIGeneratedFields = {}

        // Update form data with generated content
        setFormData((prev) => {
          const updated = { ...prev }

          if (generatedFields.projectTitle && !prev.projectTitle) {
            updated.projectTitle = generatedFields.projectTitle
            newAiGeneratedFields.projectTitle = true
          }

          if (generatedFields.shortDescription && !prev.shortDescription) {
            updated.shortDescription = generatedFields.shortDescription
            newAiGeneratedFields.shortDescription = true
          }

          if (generatedFields.longDescription && !prev.longDescription) {
            updated.longDescription = generatedFields.longDescription
            newAiGeneratedFields.longDescription = true
          }

          // Handle new core required fields
          if (generatedFields.primaryGenres && prev.primaryGenres.length === 0) {
            updated.primaryGenres = generatedFields.primaryGenres
          }

          if (generatedFields.corePremise && !prev.corePremise) {
            updated.corePremise = generatedFields.corePremise
          }

          if (generatedFields.targetAudience && prev.targetAudience.length === 0) {
            updated.targetAudience = generatedFields.targetAudience
          }

          if (generatedFields.tone && prev.tone.length === 0) {
            updated.tone = generatedFields.tone
          }

          return updated
        })

        // Track which fields were AI-generated
        setAiGeneratedFields((prev) => ({ ...prev, ...newAiGeneratedFields }))

        const fieldCount = Object.keys(newAiGeneratedFields).length
        success(
          'AI Auto-fill Complete',
          `Successfully generated ${fieldCount} field${fieldCount > 1 ? 's' : ''}!`,
        )
      } else {
        // Handle specific error types with user-friendly messages
        let errorTitle = 'AI Auto-fill Failed'
        let errorMessage = result.error || 'Failed to generate content. Please try again.'

        if (result.errorType === 'INSUFFICIENT_CREDITS') {
          errorTitle = 'AI Service Credits Exhausted'
          errorMessage =
            result.userMessage ||
            'The AI service has run out of credits. Please contact support or try again later.'
        } else if (result.errorType === 'SERVICE_UNAVAILABLE') {
          errorTitle = 'AI Service Temporarily Unavailable'
          errorMessage =
            result.userMessage ||
            'The AI content generation service is temporarily unavailable. Please try again later.'
        } else if (
          result.errorType === 'AI_SERVICE_ERROR' ||
          result.errorType === 'AI_GENERATION_ERROR'
        ) {
          errorTitle = 'AI Service Error'
          errorMessage =
            result.userMessage ||
            'There was an issue with the AI service. Please try again in a few moments.'
        } else if (result.userMessage) {
          errorMessage = result.userMessage
        }

        error(errorTitle, errorMessage)
      }
    } catch (err) {
      console.error('AI auto-fill error:', err)
      error(
        'AI Auto-fill Error',
        'Network error occurred. Please check your connection and try again.',
      )
    } finally {
      setAiLoading(false)
    }
  }

  // Handle Core Story Elements AI auto-fill
  const handleCoreElementsAIFill = async () => {
    if (!areRequiredFieldsFilled()) {
      error('AI Auto-fill Error', 'Please fill in all required fields first.')
      return
    }

    setCoreElementsAiLoading(true)

    try {
      const response = await fetch('/v1/projects/core-elements-autofill', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          name: formData.name,
          movieFormat: formData.movieFormat,
          movieStyle: formData.movieStyle,
          series: formData.series,
          durationUnit: formData.durationUnit,
          // Current core elements values
          primaryGenres: formData.primaryGenres,
          corePremise: formData.corePremise,
          targetAudience: formData.targetAudience,
          tone: formData.tone,
        }),
      })

      const result = await response.json()

      if (!response.ok) {
        // Handle specific error types
        if (result.errorType === 'INSUFFICIENT_CREDITS') {
          error('AI Credits Exhausted', result.userMessage || 'AI service credits exhausted.')
          return
        }

        if (result.errorType === 'AI_GENERATION_ERROR') {
          error('AI Generation Failed', result.userMessage || 'AI generation failed.')
          return
        }

        // Handle validation errors
        if (result.details && Array.isArray(result.details)) {
          const fieldErrors = result.details.reduce(
            (acc: FormErrors, detail: { field: string; message: string }) => {
              acc[detail.field] = detail.message
              return acc
            },
            {},
          )
          setErrors((prev) => ({ ...prev, ...fieldErrors }))
        }

        const errorTitle =
          result.errorType === 'AI_SERVICE_ERROR' ? 'AI Service Error' : 'AI Auto-fill Error'
        const errorMessage =
          result.userMessage || result.error || 'Failed to generate core story elements'

        error(errorTitle, errorMessage)
        return
      }

      if (result.success && result.data?.generatedFields) {
        const generatedFields = result.data.generatedFields

        // Update form data with generated fields
        setFormData((prev) => {
          const updated = { ...prev }

          if (generatedFields.primaryGenres && generatedFields.primaryGenres.length > 0) {
            updated.primaryGenres = generatedFields.primaryGenres
          }

          if (generatedFields.corePremise && !prev.corePremise) {
            updated.corePremise = generatedFields.corePremise
          }

          if (generatedFields.targetAudience && generatedFields.targetAudience.length > 0) {
            updated.targetAudience = generatedFields.targetAudience
          }

          if (generatedFields.tone && generatedFields.tone.length > 0) {
            updated.tone = generatedFields.tone
          }

          return updated
        })

        const fieldCount = Object.keys(generatedFields).length
        success(
          'Core Elements Generated',
          `Successfully generated ${fieldCount} core story element${fieldCount > 1 ? 's' : ''}!`,
        )
      } else {
        error('AI Auto-fill Error', result.error || 'No fields were generated')
      }
    } catch (err) {
      console.error('Core elements AI auto-fill error:', err)
      error(
        'AI Auto-fill Error',
        'Network error occurred. Please check your connection and try again.',
      )
    } finally {
      setCoreElementsAiLoading(false)
    }
  }

  // Handle AI content reset
  const handleAIReset = () => {
    setFormData((prev) => ({
      ...prev,
      ...(aiGeneratedFields.projectTitle && { projectTitle: '' }),
      ...(aiGeneratedFields.shortDescription && { shortDescription: '' }),
      ...(aiGeneratedFields.longDescription && { longDescription: '' }),
      // Reset core required fields if they were AI-generated
      primaryGenres: [],
      corePremise: '',
      targetAudience: [],
      tone: [],
    }))

    setAiGeneratedFields({})
    success('AI Content Reset', 'AI-generated content has been cleared.')
  }

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {}

    if (!formData.name.trim()) {
      newErrors.name = 'Project name is required'
    }

    if (!formData.movieFormat) {
      newErrors.movieFormat = 'Movie format is required'
    }

    if (!formData.movieStyle) {
      newErrors.movieStyle = 'Movie style is required'
    }

    if (!formData.durationUnit) {
      newErrors.durationUnit = 'Duration unit is required'
    }

    if (showSeriesField && !formData.series) {
      newErrors.series = 'Series is required when movie format is "Series"'
    }

    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) {
      return
    }

    setLoading(true)

    try {
      const submitData = {
        ...formData,
        // Only include series if it's needed
        ...(showSeriesField ? { series: formData.series } : {}),
      }

      const response = await fetch('/v1/projects', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(submitData),
      })

      const result = await response.json()

      if (result.success) {
        success('Project created successfully!', 'Redirecting to projects page...')
        setTimeout(() => router.push('/projects'), 1000)
      } else {
        error('Failed to create project', result.error || 'Please check your input and try again.')
        setErrors({ submit: result.error || 'Failed to create project' })
      }
    } catch (err) {
      console.error('Error creating project:', err)
      error('Failed to create project', 'Please try again.')
      setErrors({ submit: 'Failed to create project. Please try again.' })
    } finally {
      setLoading(false)
    }
  }

  if (initialLoading) {
    return (
      <DashboardLayout
        title="Create New Project"
        subtitle="Fill in the details to create your movie project"
      >
        <div className="flex justify-center items-center h-64">
          <LoadingSpinner size="lg" />
        </div>
      </DashboardLayout>
    )
  }

  const movieFormatOptions = movieFormats.map((format) => ({
    value: format.id,
    label: format.name,
  }))

  const movieStyleOptions = movieStyles.map((style) => ({
    value: style.id,
    label: style.name,
  }))

  const seriesOptions = seriesList.map((series) => ({
    value: series.id,
    label: series.name,
  }))

  // Options for new core required fields
  const genreOptions = genres.map((genre) => ({
    value: genre.id,
    label: genre.name,
  }))

  const audienceOptions = audienceDemographics.map((audience) => ({
    value: audience.id,
    label: audience.name,
  }))

  const toneOptionsForSelect = toneOptions.map((tone) => ({
    value: tone.id,
    label: tone.name,
  }))

  return (
    <DashboardLayout
      title="Create New Project"
      subtitle="Fill in the details to create your movie project"
      showSearch={false}
    >
      {/* Full-width multi-column layout */}
      <div className="max-w-7xl mx-auto">
        <form onSubmit={handleSubmit} className="space-y-8">
          {/* Required Fields Section - Highlighted */}
          <div className="bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 shadow-sm rounded-lg p-6">
            <div className="mb-6">
              <div className="flex items-center gap-2">
                <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                <h3 className="text-lg font-semibold text-gray-900">Required Information</h3>
              </div>
              <p className="text-sm text-blue-700 mt-1">
                Please fill in all required fields to create your project
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              <FormField
                label="Project Name"
                required
                error={errors.name}
                description="A unique identifier for your project"
              >
                <Input
                  type="text"
                  value={formData.name}
                  onChange={(e) => handleInputChange('name', e.target.value)}
                  placeholder="Enter project name"
                  error={!!errors.name}
                />
              </FormField>

              <FormField
                label="Movie Format"
                required
                error={errors.movieFormat}
                description="The format type for this project"
              >
                <Select
                  value={formData.movieFormat}
                  onChange={(e) => handleInputChange('movieFormat', e.target.value)}
                  options={movieFormatOptions}
                  placeholder="Select movie format"
                  error={!!errors.movieFormat}
                />
              </FormField>

              {showSeriesField && (
                <FormField
                  label="Series"
                  required
                  error={errors.series}
                  description="Associated series for this episode"
                >
                  <SelectWithCreate
                    value={formData.series}
                    onChange={(value) => handleInputChange('series', value)}
                    options={seriesOptions}
                    placeholder="Select series"
                    error={!!errors.series}
                    onCreateClick={() => setShowCreateSeriesModal(true)}
                    createLabel="Create New Series"
                  />
                </FormField>
              )}

              <FormField
                label="Movie Style"
                required
                error={errors.movieStyle}
                description="Visual/artistic style for AI generation"
              >
                <Select
                  value={formData.movieStyle}
                  onChange={(e) => handleInputChange('movieStyle', e.target.value)}
                  options={movieStyleOptions}
                  placeholder="Select movie style"
                  error={!!errors.movieStyle}
                />
              </FormField>

              <FormField
                label="Duration (Minutes)"
                required
                error={errors.durationUnit}
                description="Suggested duration for this project in minutes"
              >
                <Input
                  type="number"
                  value={formData.durationUnit}
                  onChange={(e) => handleInputChange('durationUnit', e.target.value)}
                  placeholder="Enter duration in minutes"
                  error={!!errors.durationUnit}
                  min="1"
                  step="1"
                />
              </FormField>
            </div>
          </div>

          {/* Core Required Fields for Story Generation */}
          <div className="bg-gradient-to-r from-purple-50 to-pink-50 border border-purple-200 shadow-sm rounded-lg p-6">
            <div className="mb-6">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <div className="w-2 h-2 bg-purple-500 rounded-full"></div>
                  <h3 className="text-lg font-semibold text-gray-900">Core Story Elements</h3>
                </div>
                {/* AI Auto-fill Button for Core Story Elements */}
                {areRequiredFieldsFilled() && (
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={handleCoreElementsAIFill}
                    loading={coreElementsAiLoading}
                    disabled={coreElementsAiLoading}
                    className="flex items-center gap-2 bg-gradient-to-r from-purple-50 to-pink-50 border-purple-200 text-purple-700 hover:from-purple-100 hover:to-pink-100 hover:border-purple-300"
                  >
                    <Sparkles className="w-4 h-4" />
                    {coreElementsAiLoading ? 'Generating...' : 'AI Auto-fill'}
                  </Button>
                )}
              </div>
              <p className="text-sm text-purple-700 mt-1">
                Essential elements that will drive your story generation and creative direction
              </p>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <FormField
                label="Primary Genres"
                error={errors.primaryGenres}
                description="Select up to 3 genres in order of importance"
              >
                <MultiSelect
                  value={formData.primaryGenres}
                  onChange={(values) => handleInputChange('primaryGenres', values.slice(0, 3))}
                  options={genreOptions}
                  placeholder="Select genres"
                  maxSelections={3}
                  error={!!errors.primaryGenres}
                />
              </FormField>

              <FormField
                label="Target Audience"
                error={errors.targetAudience}
                description="Select primary demographic groups this story should appeal to"
              >
                <MultiSelect
                  value={formData.targetAudience}
                  onChange={(values) => handleInputChange('targetAudience', values.slice(0, 3))}
                  options={audienceOptions}
                  placeholder="Select target audience"
                  maxSelections={3}
                  error={!!errors.targetAudience}
                />
              </FormField>

              <FormField
                label="Tone & Mood"
                error={errors.tone}
                description="Select 1-2 tones that define the story's emotional approach"
              >
                <MultiSelect
                  value={formData.tone}
                  onChange={(values) => handleInputChange('tone', values.slice(0, 2))}
                  options={toneOptionsForSelect}
                  placeholder="Select tone options"
                  maxSelections={2}
                  error={!!errors.tone}
                />
              </FormField>

              <div className="md:col-span-2">
                <FormField
                  label="Core Premise"
                  error={errors.corePremise}
                  description="The central story concept and main conflict - what is this story about? (50-500 words)"
                >
                  <Textarea
                    value={formData.corePremise}
                    onChange={(e) => handleInputChange('corePremise', e.target.value)}
                    placeholder="Describe the central story concept, main conflict, and what drives the narrative..."
                    rows={4}
                    error={!!errors.corePremise}
                  />
                </FormField>
              </div>
            </div>
          </div>

          {/* Optional Project Details Section */}
          <div className="bg-white shadow-sm rounded-lg p-6">
            <div className="mb-6">
              <div className="flex items-center justify-between">
                <div>
                  <h3 className="text-lg font-semibold text-gray-900">Project Details</h3>
                  <p className="text-sm text-gray-500 mt-1">
                    Additional information about your project (optional)
                  </p>
                </div>

                {/* AI Auto-fill Button - appears when required fields are filled */}
                {areRequiredFieldsFilled() && (
                  <div className="flex items-center gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={handleAIAutoFill}
                      loading={aiLoading}
                      disabled={aiLoading}
                      className="flex items-center gap-2 bg-gradient-to-r from-purple-50 to-pink-50 border-purple-200 text-purple-700 hover:from-purple-100 hover:to-pink-100 hover:border-purple-300"
                    >
                      <Sparkles className="w-4 h-4" />
                      {aiLoading ? 'Generating...' : 'AI Auto-fill'}
                    </Button>

                    {/* Reset button - appears when AI content exists */}
                    {Object.keys(aiGeneratedFields).length > 0 && (
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={handleAIReset}
                        className="flex items-center gap-2 bg-red-50 border-red-200 text-red-700 hover:bg-red-100 hover:border-red-300"
                        title="Clear AI-generated content"
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    )}
                  </div>
                )}
              </div>
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <FormField
                label="Project Title"
                error={errors.projectTitle}
                description="The actual title of the movie/episode (can be auto-generated)"
              >
                <Input
                  type="text"
                  value={formData.projectTitle}
                  onChange={(e) => handleInputChange('projectTitle', e.target.value)}
                  placeholder="Enter project title"
                  error={!!errors.projectTitle}
                />
              </FormField>

              <FormField
                label="Short Description"
                error={errors.shortDescription}
                description="Brief summary of the project"
              >
                <Textarea
                  value={formData.shortDescription}
                  onChange={(e) => handleInputChange('shortDescription', e.target.value)}
                  placeholder="Enter a brief description"
                  rows={3}
                  error={!!errors.shortDescription}
                />
              </FormField>

              <div className="lg:col-span-2">
                <FormField
                  label="Long Description"
                  error={errors.longDescription}
                  description="Detailed description or synopsis of the project"
                >
                  <Textarea
                    value={formData.longDescription}
                    onChange={(e) => handleInputChange('longDescription', e.target.value)}
                    placeholder="Enter detailed description"
                    rows={4}
                    error={!!errors.longDescription}
                  />
                </FormField>
              </div>
            </div>
          </div>

          {/* Form Actions */}
          <div className="bg-white shadow-sm rounded-lg p-6">
            {errors.submit && (
              <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-md">
                <div className="text-red-600 text-sm">{errors.submit}</div>
              </div>
            )}

            <div className="flex justify-end space-x-4">
              <Button
                type="button"
                variant="outline"
                onClick={() => router.back()}
                disabled={loading}
              >
                Cancel
              </Button>
              <Button type="submit" loading={loading}>
                Create Project
              </Button>
            </div>
          </div>
        </form>
      </div>
      <ToastContainer toasts={toasts} removeToast={removeToast} />
      <CreateSeriesModal
        isOpen={showCreateSeriesModal}
        onClose={() => setShowCreateSeriesModal(false)}
        onSeriesCreated={handleSeriesCreated}
      />
    </DashboardLayout>
  )
}
