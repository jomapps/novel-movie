# PayloadCMS Field Types Guide

## Critical Field Type Considerations

### ⚠️ AVOID richText Fields for AI-Generated Content

**Problem**: PayloadCMS richText fields use the Lexical editor, which expects structured JSON data in a specific format. When string data is passed to richText fields, it causes corruption and errors.

**Error Example**:
```
The value passed to the Lexical editor is not an object. This is not supported. 
Please remove the data from the field and start again.
```

**Solution**: Use `textarea` fields instead of `richText` for any content that will be:
- Generated by AI systems
- Imported from external sources
- Populated programmatically with string data
- Potentially containing plain text rather than structured content

### Recommended Field Types

#### For Long-Form Text Content

**❌ DON'T USE:**
```typescript
{
  name: 'description',
  type: 'richText',  // Causes issues with AI-generated content
  required: true,
}
```

**✅ USE INSTEAD:**
```typescript
{
  name: 'description',
  type: 'textarea',  // Safe for all text content
  required: true,
  admin: {
    rows: 6,  // Control height
    description: 'Detailed description of the content',
  },
}
```

#### For Short Text Content

**✅ RECOMMENDED:**
```typescript
{
  name: 'title',
  type: 'text',  // For single-line text
  required: true,
  maxLength: 200,
}
```

#### For Structured Content (User-Created Only)

**✅ SAFE TO USE richText:**
```typescript
{
  name: 'userNotes',
  type: 'richText',  // Only when users create content directly in admin
  admin: {
    description: 'Rich text notes created by users in the admin interface',
  },
}
```

## Field Type Guidelines by Use Case

### AI-Generated Content Fields

All fields that will receive AI-generated content should use `textarea`:

```typescript
// Story premises, character descriptions, scene descriptions
{
  name: 'corePremise',
  type: 'textarea',
  required: true,
  admin: {
    rows: 8,
    description: 'AI-generated or user-written story premise',
  },
}

// Character backgrounds, motivations
{
  name: 'characterBackground',
  type: 'textarea',
  admin: {
    rows: 6,
    description: 'Character history and motivation',
  },
}

// Scene descriptions, dialogue
{
  name: 'sceneDescription',
  type: 'textarea',
  admin: {
    rows: 10,
    description: 'Detailed scene description and action',
  },
}
```

### User Input Fields

Fields where users directly input content can use appropriate types:

```typescript
// Short user inputs
{
  name: 'projectName',
  type: 'text',
  required: true,
  maxLength: 100,
}

// Medium user inputs
{
  name: 'userNotes',
  type: 'textarea',
  admin: {
    rows: 4,
    placeholder: 'Add your notes here...',
  },
}

// Rich user content (admin interface only)
{
  name: 'detailedNotes',
  type: 'richText',
  admin: {
    description: 'Rich text notes with formatting (user-created only)',
  },
}
```

### Configuration and Lookup Fields

For configuration collections, use appropriate simple types:

```typescript
{
  name: 'description',
  type: 'textarea',  // Even for config, use textarea for descriptions
  required: true,
  admin: {
    rows: 3,
    description: 'Description of this option',
  },
}

{
  name: 'name',
  type: 'text',
  required: true,
  unique: true,
}
```

## Data Migration Considerations

### Converting richText to textarea

If you have existing richText fields that need to be converted:

1. **Update the collection definition** from `richText` to `textarea`
2. **Create a migration script** to convert existing data:

```typescript
// migration script example
const convertRichTextToPlainText = async () => {
  const payload = await getPayload({ config })
  
  const documents = await payload.find({
    collection: 'your-collection',
    limit: 1000,
  })
  
  for (const doc of documents.docs) {
    if (doc.richTextField && typeof doc.richTextField === 'object') {
      // Extract plain text from Lexical JSON structure
      const plainText = extractPlainTextFromLexical(doc.richTextField)
      
      await payload.update({
        collection: 'your-collection',
        id: doc.id,
        data: {
          textareaField: plainText,
        },
      })
    }
  }
}
```

3. **Test thoroughly** before deploying to production

### Handling Existing richText Data

If you encounter corrupted richText data:

1. **Identify affected documents**:
```typescript
const findCorruptedDocs = await payload.find({
  collection: 'your-collection',
  where: {
    richTextField: {
      exists: true,
    },
  },
})
```

2. **Clear corrupted data** and allow users to re-enter:
```typescript
await payload.update({
  collection: 'your-collection',
  id: docId,
  data: {
    richTextField: null,  // Clear the corrupted field
  },
})
```

## Best Practices

### 1. Field Type Selection Checklist

Before choosing a field type, ask:
- ✅ Will this field receive AI-generated content? → Use `textarea`
- ✅ Will this field be populated programmatically? → Use `textarea` or `text`
- ✅ Do users need rich formatting? → Only use `richText` if content is created in admin
- ✅ Is this a short, single-line input? → Use `text`
- ✅ Is this a long-form text input? → Use `textarea`

### 2. Admin Interface Configuration

Enhance textarea fields with proper admin configuration:

```typescript
{
  name: 'longDescription',
  type: 'textarea',
  admin: {
    rows: 8,  // Set appropriate height
    placeholder: 'Enter detailed description...',
    description: 'Comprehensive description with context',
  },
  validate: (value) => {
    if (value && value.length < 50) {
      return 'Description must be at least 50 characters'
    }
    return true
  },
}
```

### 3. Validation and Constraints

Add appropriate validation for textarea fields:

```typescript
{
  name: 'storyPremise',
  type: 'textarea',
  required: true,
  validate: (value) => {
    if (!value) return 'Story premise is required'
    
    const wordCount = value.split(/\s+/).length
    if (wordCount < 50) return 'Story premise must be at least 50 words'
    if (wordCount > 500) return 'Story premise must not exceed 500 words'
    
    return true
  },
  admin: {
    rows: 6,
    description: 'Story premise (50-500 words)',
  },
}
```

## Summary

- **Always use `textarea`** for AI-generated or programmatically populated text content
- **Use `text`** for short, single-line inputs
- **Only use `richText`** when users create content directly in the PayloadCMS admin interface
- **Test field types thoroughly** with your data sources before production deployment
- **Migrate existing richText fields** that receive external data to prevent corruption

Following these guidelines will prevent data corruption issues and ensure reliable content management across your PayloadCMS collections.
